import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { connectDB } from '@/lib/db/connect'
import { Standup, Project } from '@/lib/db/models'
import { getExecutive, type AgentId } from '@/lib/config/executives'
import {
  startStandup,
  generateParticipantReports,
  completeStandup,
  scheduleAutoDailyStandup,
} from '@/lib/services/standup-service'
import type { StandupType, AgendaItem } from '@/lib/db/models/standup'

/**
 * GET /api/standups
 * è·å–ä¾‹ä¼šåˆ—è¡¨æˆ–å•ä¸ªä¾‹ä¼šè¯¦æƒ…
 */
export async function GET(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    await connectDB()
    const { searchParams } = new URL(req.url)
    const standupId = searchParams.get('id')
    const projectId = searchParams.get('projectId')
    const upcoming = searchParams.get('upcoming') === 'true'

    // è·å–å•ä¸ªä¾‹ä¼šè¯¦æƒ…
    if (standupId) {
      const standup = await Standup.findOne({
        _id: standupId,
        userId: session.user.id,
      }).populate('projectId', 'name')

      if (!standup) {
        return NextResponse.json(
          { error: 'Standup not found' },
          { status: 404 }
        )
      }

      const project = standup.projectId as any

      return NextResponse.json({
        success: true,
        standup: {
          id: standup._id.toString(),
          projectId: project._id.toString(),
          projectName: project.name,
          type: standup.type,
          title: standup.title,
          status: standup.status,
          scheduledAt: standup.scheduledAt,
          startedAt: standup.startedAt,
          endedAt: standup.endedAt,
          participants: standup.participants.map((p) => {
            const exec = getExecutive(p)
            return {
              id: p,
              name: exec?.nameCn || p,
              title: exec?.titleCn || '',
              avatar: exec?.avatar || 'ğŸ‘¤',
            }
          }),
          agenda: standup.agenda,
          reports: standup.reports.map((r) => {
            const exec = getExecutive(r.agentId)
            return {
              ...r,
              agentName: exec?.nameCn || r.agentId,
              agentTitle: exec?.titleCn || '',
              agentAvatar: exec?.avatar || 'ğŸ‘¤',
            }
          }),
          minutes: standup.minutes,
          isAutoGenerated: standup.isAutoGenerated,
        },
      })
    }

    // è·å–å³å°†è¿›è¡Œçš„ä¾‹ä¼š
    if (upcoming) {
      const standups = await Standup.getUpcomingStandups(
        session.user.id as any,
        projectId ? (projectId as any) : undefined
      )

      return NextResponse.json({
        success: true,
        standups: standups.map((s) => ({
          id: s._id.toString(),
          projectId: (s.projectId as any).toString(),
          type: s.type,
          title: s.title,
          status: s.status,
          scheduledAt: s.scheduledAt,
          participantsCount: s.participants.length,
        })),
      })
    }

    // è·å–é¡¹ç›®ä¾‹ä¼šè®°å½•
    if (projectId) {
      // éªŒè¯é¡¹ç›®æ‰€æœ‰æƒ
      const project = await Project.findOne({
        _id: projectId,
        userId: session.user.id,
      })

      if (!project) {
        return NextResponse.json(
          { error: 'Project not found' },
          { status: 404 }
        )
      }

      const standups = await Standup.getProjectStandups(projectId as any, 20)

      return NextResponse.json({
        success: true,
        standups: standups.map((s) => ({
          id: s._id.toString(),
          type: s.type,
          title: s.title,
          status: s.status,
          scheduledAt: s.scheduledAt,
          endedAt: s.endedAt,
          participantsCount: s.participants.length,
          hasMintes: !!s.minutes,
        })),
      })
    }

    return NextResponse.json(
      { error: 'Missing projectId or id parameter' },
      { status: 400 }
    )
  } catch (error) {
    console.error('Failed to get standups:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * POST /api/standups
 * åˆ›å»ºä¾‹ä¼šæˆ–æ‰§è¡Œä¾‹ä¼šæ“ä½œ
 */
export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    await connectDB()
    const body = await req.json()
    const { action } = body

    // å®‰æ’æ–°ä¾‹ä¼š
    if (action === 'schedule') {
      const { projectId, type, title, scheduledAt, participants, agenda } = body as {
        projectId: string
        type: StandupType
        title: string
        scheduledAt: string
        participants: AgentId[]
        agenda?: AgendaItem[]
      }

      // éªŒè¯é¡¹ç›®æ‰€æœ‰æƒ
      const project = await Project.findOne({
        _id: projectId,
        userId: session.user.id,
      })

      if (!project) {
        return NextResponse.json(
          { error: 'Project not found' },
          { status: 404 }
        )
      }

      const standup = await Standup.scheduleStandup({
        userId: session.user.id as any,
        projectId: projectId as any,
        type,
        title,
        scheduledAt: new Date(scheduledAt),
        participants,
        agenda,
        isAutoGenerated: false,
      })

      return NextResponse.json({
        success: true,
        standup: {
          id: standup._id.toString(),
          title: standup.title,
          scheduledAt: standup.scheduledAt,
        },
      })
    }

    // å¼€å¯è‡ªåŠ¨æ¯æ—¥ä¾‹ä¼š
    if (action === 'enable_auto_daily') {
      const { projectId } = body

      const standup = await scheduleAutoDailyStandup(session.user.id, projectId)

      return NextResponse.json({
        success: true,
        message: 'å·²å¼€å¯æ¯æ—¥ä¾‹ä¼š',
        standup: {
          id: standup._id.toString(),
          scheduledAt: standup.scheduledAt,
        },
      })
    }

    // å¼€å§‹ä¾‹ä¼š
    if (action === 'start') {
      const { standupId } = body

      // éªŒè¯æ‰€æœ‰æƒ
      const existingStandup = await Standup.findOne({
        _id: standupId,
        userId: session.user.id,
      })

      if (!existingStandup) {
        return NextResponse.json(
          { error: 'Standup not found' },
          { status: 404 }
        )
      }

      const standup = await startStandup(standupId)

      return NextResponse.json({
        success: true,
        standup: {
          id: standup._id.toString(),
          status: standup.status,
          startedAt: standup.startedAt,
        },
      })
    }

    // ç”Ÿæˆæ±‡æŠ¥
    if (action === 'generate_reports') {
      const { standupId } = body

      // éªŒè¯æ‰€æœ‰æƒ
      const existingStandup = await Standup.findOne({
        _id: standupId,
        userId: session.user.id,
      })

      if (!existingStandup) {
        return NextResponse.json(
          { error: 'Standup not found' },
          { status: 404 }
        )
      }

      const reports = await generateParticipantReports(standupId)

      return NextResponse.json({
        success: true,
        reports: reports.map((r) => {
          const exec = getExecutive(r.agentId)
          return {
            ...r,
            agentName: exec?.nameCn || r.agentId,
          }
        }),
      })
    }

    // å®Œæˆä¾‹ä¼š
    if (action === 'complete') {
      const { standupId } = body

      // éªŒè¯æ‰€æœ‰æƒ
      const existingStandup = await Standup.findOne({
        _id: standupId,
        userId: session.user.id,
      })

      if (!existingStandup) {
        return NextResponse.json(
          { error: 'Standup not found' },
          { status: 404 }
        )
      }

      const standup = await completeStandup(standupId)

      return NextResponse.json({
        success: true,
        standup: {
          id: standup._id.toString(),
          status: standup.status,
          endedAt: standup.endedAt,
          minutes: standup.minutes,
        },
      })
    }

    return NextResponse.json(
      { error: 'Invalid action' },
      { status: 400 }
    )
  } catch (error) {
    console.error('Failed to process standup request:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * DELETE /api/standups
 * å–æ¶ˆä¾‹ä¼š
 */
export async function DELETE(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    await connectDB()
    const { searchParams } = new URL(req.url)
    const standupId = searchParams.get('id')

    if (!standupId) {
      return NextResponse.json(
        { error: 'Missing standup id' },
        { status: 400 }
      )
    }

    const standup = await Standup.findOne({
      _id: standupId,
      userId: session.user.id,
    })

    if (!standup) {
      return NextResponse.json(
        { error: 'Standup not found' },
        { status: 404 }
      )
    }

    if (standup.status !== 'scheduled') {
      return NextResponse.json(
        { error: 'Can only cancel scheduled standups' },
        { status: 400 }
      )
    }

    standup.status = 'cancelled'
    await standup.save()

    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Failed to cancel standup:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
