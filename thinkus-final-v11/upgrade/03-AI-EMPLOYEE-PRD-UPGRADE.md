# Thinkus AI员工增强方案 - 产品需求文档

> **版本**: v1.0 | **日期**: 2026-01-15
>
> **核心理念**: AI员工要像员工：对外一个人；要像系统：对内分层、隔离、卸载
>
> **记忆目标**: 不是"记住一切"，而是"在需要时想起最少但足够的信息"

---

## 一、背景与问题

### 1.1 当前系统现状

```yaml
现有能力:
  ✅ 18个AI高管，每个用户独立实例
  ✅ 双层记忆架构（跨项目+项目专属）
  ✅ 向量检索（Pinecone）
  ✅ 用户隔离（userId + namespace）

存在问题:
  ❌ 记忆检索不够智能（总是检索，不判断是否需要）
  ❌ 工具结果直接塞进上下文（token爆炸）
  ❌ 会话没有结构化摘要（信息丢失）
  ❌ 记忆没有衰减和纠错机制（垃圾累积）
  ❌ 检索模式单一（没有catalog→details两阶段）
```

### 1.2 升级目标

```yaml
核心目标:
  1. 智能记忆控制: AI自己决定是否需要记忆、需要多少
  2. 工具结果卸载: Full内容存外部，只注入Compact摘要
  3. 会话摘要: 每次会话生成结构化摘要，便于后续检索
  4. 记忆质量管理: 衰减、合并、纠错机制
  5. 两阶段检索: 先catalog概览，再details详情

预期效果:
  - Token消耗降低50%+
  - 记忆检索准确率提升
  - 长期记忆质量持续提高
  - AI响应更加相关和个性化
```

---

## 二、核心概念

### 2.1 AI员工架构升级

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│   升级后的AI员工架构 (单个高管实例)                                     │
│                                                                          │
│   用户输入                                                               │
│       │                                                                  │
│       ▼                                                                  │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                     Employee Core (高管人格)                     │   │
│   │   - 保持统一人格对外                                            │   │
│   │   - 整合各模块输出                                              │   │
│   └───────────────────────────┬─────────────────────────────────────┘   │
│                               │                                          │
│       ┌───────────────────────┼───────────────────────┐                 │
│       │                       │                       │                 │
│       ▼                       ▼                       ▼                 │
│   ┌─────────┐          ┌─────────────┐          ┌─────────────┐        │
│   │ Memory  │          │   Planner   │          │  Knowledge  │        │
│   │Controller│         │  (规划器)    │          │  Manager    │        │
│   │(记忆控制)│         │             │          │ (知识管理)  │        │
│   └────┬────┘          └──────┬──────┘          └──────┬──────┘        │
│        │                      │                        │                │
│        ▼                      ▼                        ▼                │
│   ┌─────────┐          ┌─────────────┐          ┌─────────────┐        │
│   │Retriever│          │  Executor   │          │  Compressor │        │
│   │(检索器) │          │  (执行器)   │          │  (压缩器)   │        │
│   └────┬────┘          └──────┬──────┘          └─────────────┘        │
│        │                      │                                         │
│        ▼                      ▼                                         │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │                        Storage Layer                             │   │
│   │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │   │
│   │  │ Memory   │  │ Artifact │  │ Session  │  │  Vector  │        │   │
│   │  │ Store    │  │ Store    │  │ Summary  │  │  Index   │        │   │
│   │  │(结构化)  │  │(Full存储)│  │ Store    │  │(Pinecone)│        │   │
│   │  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心模块职责

| 模块 | 职责 | 输入 | 输出 |
|------|------|------|------|
| Memory Controller | 判断是否需要记忆、检索模式、token预算 | 用户消息 + 上下文 | need/mode/budget |
| Retriever | 两阶段检索（catalog→details） | 查询 + mode + budget | 记忆内容 |
| Planner | 任务规划、工具选择 | 需求 + 约束 | 执行计划 |
| Executor | 在沙盒中执行工具 | 计划 | Artifact引用 |
| Knowledge Manager | 压缩、摘要、写入、纠错 | 对话/结果 | 结构化记忆 |

---

## 三、功能详细设计

### 3.1 [新增] Memory Controller (记忆控制器)

#### 3.1.1 功能概述

```yaml
问题:
  当前系统每次都检索记忆，不管是否需要
  造成token浪费和信息噪音

解决方案:
  AI自己判断是否需要记忆
  如果需要，判断检索模式和token预算
```

#### 3.1.2 判断逻辑

```yaml
判断是否需要记忆:
  需要:
    - 用户提到"之前"/"上次"/"我说过"
    - 涉及项目历史决策
    - 需要个性化建议
    - 涉及用户偏好
  
  不需要:
    - 通用知识问答
    - 明确的新任务
    - 已有足够上下文

判断检索模式:
  catalog (目录模式):
    - 用户问"我们讨论过哪些..."
    - 需要概览而非详情
    - token预算较少
  
  details (详情模式):
    - 需要具体内容
    - 决策参考
    - token预算充足

判断token预算:
  - 简单参考: 200-500 tokens
  - 深度参考: 500-1500 tokens
  - 全面回顾: 1500-3000 tokens
```

#### 3.1.3 输出Schema

```json
{
  "need_memory": "yes|no|maybe",
  "memory_types": ["project_decision", "user_preference", "discussion_conclusion"],
  "retrieval_mode": "catalog|details",
  "budget_tokens": 500,
  "time_range": "last_7_days|last_30_days|all",
  "notes": "用户在追问项目历史决策与约束"
}
```

#### 3.1.4 UI展示

```
┌─────────────────────────────────────────────────────────────────┐
│  💭 Mike正在思考...                                             │
│                                                                  │
│  [记忆检索中]                                                    │
│  ├─ 判断: 需要参考历史决策                                      │
│  ├─ 模式: details (详情)                                        │
│  ├─ 预算: 500 tokens                                            │
│  └─ 范围: 最近30天                                              │
│                                                                  │
│  找到3条相关记忆...                                             │
└─────────────────────────────────────────────────────────────────┘
```

---

### 3.2 [新增] 两阶段检索 (Catalog → Details)

#### 3.2.1 功能概述

```yaml
问题:
  当前直接返回记忆全文
  如果记忆很多，token爆炸

解决方案:
  阶段1 - Catalog: 只返回记忆目录（ID + 摘要）
  阶段2 - Details: AI选择需要的记忆，再获取详情
```

#### 3.2.2 流程示意

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│   两阶段检索流程                                                         │
│                                                                          │
│   用户问题: "我们上次讨论的技术方案是什么?"                            │
│                                                                          │
│   ──────────────────────────────────────────────────────────────────    │
│                                                                          │
│   阶段1 - Catalog检索                                                    │
│                                                                          │
│   AI收到目录:                                                           │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │ [MEM-001] 技术方案决策 - 选择Next.js + MongoDB架构 (2天前)     │   │
│   │ [MEM-002] 性能需求讨论 - 页面加载时间要求<2秒 (3天前)          │   │
│   │ [MEM-003] 部署方案讨论 - 倾向使用Vercel (3天前)                │   │
│   │ [MEM-004] UI风格偏好 - 用户喜欢简约风格 (5天前)                │   │
│   │ [MEM-005] 预算讨论 - 总预算$500 (7天前)                        │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   AI判断: "用户问技术方案，MEM-001和MEM-002最相关"                     │
│                                                                          │
│   ──────────────────────────────────────────────────────────────────    │
│                                                                          │
│   阶段2 - Details获取                                                    │
│                                                                          │
│   AI请求: "获取MEM-001和MEM-002的详细内容"                             │
│                                                                          │
│   AI收到详情:                                                           │
│   ┌─────────────────────────────────────────────────────────────────┐   │
│   │ [MEM-001] 完整内容:                                             │   │
│   │ 经过讨论，决定使用Next.js 14 + App Router作为前端框架，        │   │
│   │ MongoDB作为数据库，Tailwind CSS做样式。                        │   │
│   │ 理由: 用户熟悉React，需要SSR支持SEO...                         │   │
│   │                                                                  │   │
│   │ [MEM-002] 完整内容:                                             │   │
│   │ 用户明确要求首页加载时间<2秒，列表页<1秒...                    │   │
│   └─────────────────────────────────────────────────────────────────┘   │
│                                                                          │
│   AI生成回答: "根据我们之前的讨论，技术方案是..."                      │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

#### 3.2.3 数据结构

```typescript
// Catalog条目 (轻量)
interface MemoryCatalogEntry {
  id: string               // MEM-001
  summary: string          // 50字以内摘要
  type: MemoryType         // project_decision
  importance: number       // 1-5
  createdAt: Date
  tags: string[]
}

// Details内容 (完整)
interface MemoryDetails {
  id: string
  summary: string
  content: string          // 完整内容
  context: string          // 产生背景
  decisions: string[]      // 相关决策
  refs: ArtifactRef[]      // 关联的产物引用
}
```

---

### 3.3 [新增] Artifacts管理 (工具结果卸载)

#### 3.3.1 功能概述

```yaml
问题:
  工具执行结果（代码、分析报告等）直接放入上下文
  大文件导致token爆炸

解决方案:
  Full内容存储到外部（S3/R2）
  只在上下文中注入Compact摘要 + 引用
  AI需要时通过引用获取局部内容
```

#### 3.3.2 Full vs Compact

```yaml
Full (完整内容):
  存储位置: S3/R2/MinIO
  用途: 长期保存、下载、全文检索
  示例:
    - 生成的完整代码文件 (500行)
    - 数据分析报告 (2000字)
    - 设计方案文档 (3000字)

Compact (压缩摘要):
  存储位置: 注入上下文
  大小限制: <500 tokens
  用途: 让AI知道有这个东西，可以引用
  示例:
    - "生成了user.service.ts (200行)，包含用户注册、登录、权限验证"
    - "数据分析完成，主要结论: 转化率3.2%，低于行业平均5%"
```

#### 3.3.3 引用注入格式

```markdown
[Artifact: ART-001]
类型: 代码文件
路径: /src/services/user.service.ts
摘要: 用户服务，包含注册(50行)、登录(30行)、权限验证(40行)
大小: 200行 / 4.2KB
获取: 可通过 get_artifact("ART-001", lines="1-50") 获取局部内容
```

#### 3.3.4 局部读取

```yaml
支持的读取方式:
  - 行号区间: lines="1-50", lines="100-150"
  - 字节区间: bytes="0-1000"
  - JSONPath: path="$.data.users[0]"
  - 关键词定位: search="function login"

示例:
  AI: "我需要看user.service.ts中的登录函数"
  系统: get_artifact("ART-001", search="async login")
  返回: 第30-60行的登录函数代码
```

---

### 3.4 [新增] Session Summary (会话摘要)

#### 3.4.1 功能概述

```yaml
问题:
  长对话后，信息分散在大量消息中
  新会话开始时，需要重新理解历史

解决方案:
  每个会话结束时生成结构化摘要
  摘要包含目标、决策、进展、产物、风险等
  新会话可以快速加载摘要而非全部历史
```

#### 3.4.2 摘要Schema

```json
{
  "session_id": "sess_abc123",
  "goal": "讨论课程平台的技术方案",
  "constraints": [
    "预算$500",
    "需要2周内完成",
    "必须支持视频播放"
  ],
  "decisions": [
    {
      "what": "选择Next.js + MongoDB架构",
      "why": "用户熟悉React，需要SSR支持SEO",
      "who": "David (CTO)",
      "confidence": "high"
    },
    {
      "what": "使用Stripe作为支付方案",
      "why": "接入简单，用户在美国",
      "who": "Frank (CFO)",
      "confidence": "medium"
    }
  ],
  "progress": [
    "完成需求分析",
    "确定技术方案",
    "开始UI设计"
  ],
  "artifacts": [
    {
      "ref": "ART-001",
      "locator": "/docs/tech-spec.md",
      "desc": "技术方案文档"
    },
    {
      "ref": "ART-002",
      "locator": "/designs/homepage.fig",
      "desc": "首页设计稿"
    }
  ],
  "next_actions": [
    "Elena完成其他页面设计",
    "David开始搭建项目骨架"
  ],
  "risks": [
    "视频播放可能有版权问题，需要Tom确认",
    "支付功能需要企业资质"
  ],
  "open_questions": [
    "是否需要支持多语言？",
    "证书生成功能的具体需求？"
  ]
}
```

#### 3.4.3 摘要生成时机

```yaml
自动生成:
  - 会话结束时 (用户离开/超时)
  - 阶段完成时 (需求讨论完成、开发完成等)
  - 重要决策后

手动触发:
  - 用户说"总结一下"
  - AI判断需要阶段性总结
```

#### 3.4.4 摘要使用

```yaml
新会话开始:
  1. 加载最近的Session Summary
  2. 快速了解项目状态
  3. 无缝继续之前的工作

跨高管协作:
  1. David完成技术方案
  2. 生成Session Summary
  3. Elena开始设计时，自动获取David的摘要
  4. 无需重复沟通
```

---

### 3.5 [新增] 记忆质量管理

#### 3.5.1 记忆衰减

```yaml
机制:
  - 每条记忆有"新鲜度"分数
  - 随时间自动衰减
  - 被访问时提升新鲜度
  - 低于阈值的记忆降低优先级

衰减公式:
  freshness = base_score × decay_rate^(days_since_access)
  
  其中:
    base_score: 初始重要性 (1-5)
    decay_rate: 衰减率 (0.95)
    days_since_access: 距离上次访问的天数

示例:
  重要性5的记忆，30天未访问
  freshness = 5 × 0.95^30 = 5 × 0.21 = 1.05
  → 从"非常重要"降为"低优先级"
```

#### 3.5.2 记忆合并

```yaml
场景:
  用户多次表达相似偏好
  "我喜欢简约风格" (第1次)
  "不要太花哨" (第3次)
  "越简单越好" (第5次)

合并:
  系统识别这些是同一偏好
  合并为一条记忆，提升置信度
  
合并后:
  {
    "type": "user_preference",
    "content": "用户偏好简约设计风格",
    "confidence": 0.95,  // 多次验证，高置信度
    "evidence_count": 3,
    "last_confirmed": "2026-01-15"
  }
```

#### 3.5.3 记忆纠错

```yaml
触发条件:
  - 用户明确说"不对"/"之前说错了"
  - 新信息与旧记忆矛盾
  - AI检测到不一致

纠错动作:
  suppress: 降低权重，但保留（可能是临时变化）
  freeze: 冻结，不再用于检索（可能已过时）
  replace: 用新信息替换（明确的更正）

示例:
  用户: "预算改成$800了，不是之前说的$500"
  
  系统操作:
  1. 找到记忆 [MEM-005] "预算$500"
  2. 执行replace操作
  3. 创建新记忆 [MEM-010] "预算$800"
  4. 标记 [MEM-005] 为 "superseded_by: MEM-010"
```

#### 3.5.4 用户可见的记忆管理

```
┌─────────────────────────────────────────────────────────────────┐
│  🧠 Mike对你的记忆                                [管理记忆]    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  📌 用户偏好 (3条)                                              │
│  ├─ 喜欢简约设计风格 [置信度: 95%] [删除]                      │
│  ├─ 预算敏感，倾向性价比 [置信度: 80%] [删除]                  │
│  └─ 偏好React技术栈 [置信度: 70%] [删除]                       │
│                                                                  │
│  📋 项目决策 (5条)                                [查看全部]    │
│  ├─ 使用Next.js + MongoDB [2天前]                              │
│  ├─ 支付方案选择Stripe [3天前]                                 │
│  └─ ...                                                         │
│                                                                  │
│  ⚠️ 待确认 (1条)                                                │
│  └─ 预算是$500还是$800？ [确认$800] [确认$500]                 │
│                                                                  │
│  💡 Mike会根据这些记忆为你提供更个性化的建议                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 3.6 [优化] 隔离机制增强

#### 3.6.1 现有隔离 vs 增强隔离

```yaml
现有隔离 (保持):
  - user_id: 用户级隔离 ✅
  - namespace: Pinecone命名空间 ✅
  - projectId: 项目级隔离 ✅

增强隔离 (新增):
  - role_id: 高管角色隔离
  - session_id: 会话级隔离
  - visibility: 可见性控制
```

#### 3.6.2 Role隔离

```yaml
默认行为:
  - Mike的记忆只有Mike能访问
  - Elena的记忆只有Elena能访问

显式共享:
  - 某些记忆可以标记为"跨角色可见"
  - 例如: 项目决策、用户偏好

示例:
  {
    "memory_id": "MEM-001",
    "owner_role": "david",
    "visibility": "project",  // 项目内所有高管可见
    "content": "技术方案选择Next.js"
  }
  
  {
    "memory_id": "MEM-002", 
    "owner_role": "elena",
    "visibility": "private",  // 只有Elena可见
    "content": "用户喜欢蓝色调"
  }
```

#### 3.6.3 Session隔离

```yaml
规则:
  - 每个任务/会话有唯一session_id
  - Artifacts绑定session_id
  - 工作轨迹绑定session_id

好处:
  - 可以回溯特定会话的所有产物
  - 防止会话间数据污染
  - 便于生成Session Summary
```

---

## 四、用户体验设计

### 4.1 记忆透明化

```yaml
展示内容:
  - AI正在检索哪些记忆
  - AI引用了哪条记忆
  - 记忆的置信度

目的:
  - 让用户理解AI的判断依据
  - 发现记忆错误时可以纠正
  - 建立信任
```

### 4.2 记忆管理入口

```yaml
入口位置:
  - 仪表盘 → 我的AI团队 → 某高管 → 记忆管理
  - 对话中 → 点击AI引用的记忆 → 查看/编辑

管理功能:
  - 查看所有记忆
  - 删除错误记忆
  - 纠正记忆内容
  - 调整记忆优先级
```

### 4.3 会话摘要展示

```
┌─────────────────────────────────────────────────────────────────┐
│  📋 上次会话摘要                              [2小时前]         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  目标: 讨论课程平台的技术方案                                   │
│                                                                  │
│  ✅ 已完成:                                                      │
│  • 确定技术栈: Next.js + MongoDB                                │
│  • 确定支付方案: Stripe                                         │
│  • Elena开始首页设计                                            │
│                                                                  │
│  ⏳ 待处理:                                                      │
│  • 确认是否需要多语言支持                                       │
│  • Tom确认视频版权问题                                          │
│                                                                  │
│  📎 产物:                                                        │
│  • 技术方案文档 [查看]                                          │
│  • 首页设计稿 [查看]                                            │
│                                                                  │
│  [继续上次的工作] [开始新任务]                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 五、成功指标

### 5.1 技术指标

| 指标 | 当前 | 目标 |
|------|------|------|
| 平均上下文tokens | 8000 | 4000 |
| 记忆检索准确率 | 60% | 85% |
| 无效检索比例 | 40% | 10% |
| 会话摘要覆盖率 | 0% | 95% |

### 5.2 体验指标

| 指标 | 当前 | 目标 |
|------|------|------|
| AI响应相关性评分 | 3.5/5 | 4.5/5 |
| 用户纠正记忆频率 | N/A | <5%/月 |
| 记忆透明度满意度 | N/A | >80% |

---

## 六、开发优先级

### Phase 0: 止血 (1周)

| 任务 | 说明 |
|------|------|
| Artifact卸载 | Full存S3，Compact注入上下文 |
| 引用注入 | 建立引用格式和局部读取 |
| 基础Schema | Session Summary结构定义 |

### Phase 1: 可用 (2-3周)

| 任务 | 说明 |
|------|------|
| Memory Controller | 判断是否需要记忆 |
| 两阶段检索 | Catalog → Details |
| Session Summary生成 | 会话结束自动生成 |

### Phase 2: 稳定 (2-4周)

| 任务 | 说明 |
|------|------|
| 记忆衰减 | 时间衰减 + 访问提升 |
| 记忆合并 | 相似记忆合并 |
| Role隔离 | 高管间记忆隔离 |

### Phase 3: 强化 (持续)

| 任务 | 说明 |
|------|------|
| 自动纠错 | 检测矛盾并处理 |
| 记忆可视化 | 用户管理界面 |
| 跨高管协作 | Session Summary共享 |

---

## 七、与现有系统的关系

```yaml
保持不变:
  - 18个AI高管设定
  - 用户专属实例
  - Pinecone向量存储
  - MongoDB元数据存储
  - 双层记忆架构

新增:
  - Memory Controller (记忆控制器)
  - Artifact Store (产物存储)
  - Session Summary Store (会话摘要)
  - 两阶段检索机制

优化:
  - 记忆写入流程 (增加质量评估)
  - 记忆检索流程 (增加控制器)
  - 隔离机制 (增加role_id)
```

---

**配套文档**: [AI员工增强技术架构文档](./AI-EMPLOYEE-TECH-UPGRADE.md)
